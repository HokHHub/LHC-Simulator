import fs from 'fs';
import path from 'path';

// src/index.ts
var DEFAULT_FILENAME = "robots.txt";
function uniq(arr) {
  return Array.from(new Set(arr ?? []));
}
function lines(...xs) {
  return xs.filter(Boolean).map((x) => String(x));
}
function serializePolicies(policies) {
  const blocks = [];
  for (const p of policies) {
    const ua = (p.userAgent ?? "*").trim() || "*";
    const dis = uniq(p.disallow).map((d) => `Disallow: ${d}`);
    const allow = uniq(p.allow).map((a) => `Allow: ${a}`);
    const block = lines(`User-agent: ${ua}`, ...dis, ...allow, "").join("\n");
    blocks.push(block);
  }
  return blocks.join("\n").trimEnd() + "\n";
}
function defaultPolicies() {
  return [{ userAgent: "*", allow: ["/"], disallow: [] }];
}
function buildContent(ctx, opts) {
  const policies = (opts.policies && opts.policies.length ? opts.policies : void 0) ?? (opts.policyBuilder ? opts.policyBuilder(ctx) : void 0) ?? defaultPolicies();
  const head = serializePolicies(policies);
  const sitemaps = typeof opts.sitemaps === "function" ? opts.sitemaps(ctx) : Array.isArray(opts.sitemaps) ? opts.sitemaps : void 0;
  const smBlock = sitemaps?.length ? sitemaps.map((u) => `Sitemap: ${u}`).join("\n") + "\n" : "";
  const foot = typeof opts.footerComment === "function" ? opts.footerComment(ctx) : opts.footerComment ?? void 0;
  const footerBlock = foot ? `
# ${foot.trim()}
` : "";
  return (head + (smBlock ? `
${smBlock}` : "") + footerBlock).replace(/\n{3,}$/g, "\n\n");
}
async function writeFileIfChanged(filePath, content, logger) {
  try {
    const existed = fs.existsSync(filePath);
    const prev = existed ? await fs.promises.readFile(filePath, "utf8") : null;
    if (prev === content) {
      logger.info?.(`[robots] no changes: ${filePath}`);
      return false;
    }
  } catch {
  }
  await fs.promises.mkdir(path.dirname(filePath), { recursive: true });
  await fs.promises.writeFile(filePath, content, "utf8");
  logger.info(`[robots] wrote ${filePath}`);
  return true;
}
function generateRobotsTxt(options = {}) {
  const filename = options.filename ?? DEFAULT_FILENAME;
  const noStoreInDev = options.noStoreInDev ?? true;
  let resolvedConfig;
  let logger;
  let mode = "production";
  let command = "build";
  let root = process.cwd();
  const buildTxt = () => {
    const ctx = { mode, command, root };
    return buildContent(ctx, options);
  };
  return {
    name: "vite-plugin-robots-txt",
    apply: () => true,
    configResolved(config) {
      resolvedConfig = config;
      logger = config.logger;
      root = config.root ?? process.cwd();
      mode = config.mode;
      command = config.command;
    },
    async buildStart() {
      const txt = buildTxt();
      if (options.outputDir) {
        const outPath = path.resolve(root, options.outputDir, filename);
        await writeFileIfChanged(outPath, txt, logger);
      }
    },
    generateBundle() {
      const txt = buildTxt();
      this.emitFile({ type: "asset", fileName: filename, source: txt });
      logger.info(`[robots] emitted ${filename}`);
    },
    configureServer(server) {
      const base = (resolvedConfig?.base ?? "/").replace(/\/+$/, "/");
      const route = base + filename;
      server.middlewares.use(route, (_req, res) => {
        const txt = buildTxt();
        res.setHeader("Content-Type", "text/plain; charset=utf-8");
        if (noStoreInDev) {
          res.setHeader("Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
          res.setHeader("Pragma", "no-cache");
          res.setHeader("Expires", "0");
        }
        res.end(txt);
      });
      logger.info(`[robots] dev route mounted \u2192 ${route} (no-store)`);
    }
  };
}
var index_default = generateRobotsTxt;

export { index_default as default, generateRobotsTxt };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map